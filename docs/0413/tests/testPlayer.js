let _originalLevelController = null;

function setupMockVectorSystemIfNeeded() {
  const isBrowser = typeof window !== "undefined";

  const mockVector = function (x, y) {
    if (typeof x !== "number" || typeof y !== "number") {
      console.warn("üî• createVector received invalid input:", x, y);
      return {
        x: NaN, y: NaN,
        add: () => this,
        sub: () => this,
        setMag: () => this,
        mult: () => this,
        copy: () => this,
        toString: () => `(NaN, NaN)`
      };
    }

    return {
      x,
      y,
      add(dx, dy) {
        if (typeof dx === "object") {
          this.x += dx.x;
          this.y += dx.y;
        } else {
          this.x += dx;
          this.y += dy;
        }
        return this;
      },
      sub(v) {
        return mockVector(this.x - v.x, this.y - v.y);
      },
      mult(n) {
        this.x *= n;
        this.y *= n;
        return this;
      },
      setMag(mag) {
        const len = Math.sqrt(this.x * this.x + this.y * this.y);
        if (len === 0) return this;
        this.x = (this.x / len) * mag;
        this.y = (this.y / len) * mag;
        return this;
      },
      copy() {
        return mockVector(this.x, this.y);
      },
      toString() {
        return `(${this.x.toFixed(1)}, ${this.y.toFixed(1)})`;
      }
    };
  };

  globalThis.createVector = mockVector;

  globalThis.p5 = {
    Vector: {
      sub: (a, b) => mockVector(a.x - b.x, a.y - b.y),
      add: (a, b) => mockVector(a.x + b.x, a.y + b.y)
    }
  };

  console.log("üß™ Mock vector system injected for Bullet.js usage.");
}




function runPlayerTests() {
  console.log("=== Running Player Tests ===");

  _originalLevelController = LevelController;

    withMockEnv(() => {
    testPlayerInit();
    testPlayerJump();
    testPlayerInjury();
    testPlayerCollectHeart();
    testPlayerCollectKey();
    testPlayerUseKeyOnDoor();
    testPlayerIsAlive();
    testPlayerMoveLeft();
    testPlayerMoveRight();
    testPlayerShoot();
    testBulletReflection();
    testPlayerTeleportation();
    testPlayerPortalEntryDirectionStrict();


  });

  // Restore the original LevelController
  LevelController = _originalLevelController;

  console.log("‚úÖ All Player tests completed!");
}

function withMockEnv(mockFunc) {
  setupMockVectorSystemIfNeeded(); 
    // Fully mock the methods in CollisionController to ensure they work in the tests
    const mockCollisionController = {
      // Mock the isSolid method, defaulting to false, indicating no obstacles
      isSolid: (x, y, useWorldCoords = true) => false,
  
      // Additional mocked methods can be added here
      getCollidingEnemy: () => ({ type: "enemy" }),
      isTouching: () => null,
      isItem: () => false,
      isEnemy: () => false,
    };
  
    // Save the original CollisionController reference to restore it after the tests
    const originalCollisionController = CollisionController;
  
    // Use the mocked CollisionController instead of the original one
    CollisionController = mockCollisionController;
  
    // Mock the currentMap, providing a simple map structure
    currentMap = createMockMap();
  
    const originalLevelController = LevelController;
  
    try {
      // Execute the passed-in test functions
      mockFunc();
    } catch (error) {
      console.error("Test execution failed", error);
    } finally {
      // Restore the original CollisionController and LevelController
      CollisionController = originalCollisionController;
      LevelController = originalLevelController;
    }
}

function createMockMap() {
    return {
      xOffset: 0,
      yOffset: 0,
      blocks: [...Array(20).fill().map(() => Array(20).fill(0))],
      itemList: [],
      enemyList: [],
    };
  }
  
  

function testPlayerInit() {
  const player = new Player();
  console.assert(player.pos.x === 200 && player.pos.y === 200, "‚ùå Initial position should be (200, 200)");
  console.assert(player.lives === 3, "‚ùå Initial lives should be 3");
  console.assert(player.velocity.x === 0 && player.velocity.y === 0, "‚ùå Initial velocity should be (0, 0)");
  console.log("‚úÖ testPlayerInit passed.");
}

function testPlayerInjury() {
  const player = new Player();
  player.lives = 3;
  player.injuryTimer = 0;

  // ‚úÖ Mock
  CollisionController = {
    getCollidingEnemy: () => ({ type: "enemy" }),  // Simulate collision with an enemy
    isTouching: () => null // üëà Prevent checkItemCollision error
  };

  player.update();

  console.assert(player.injured === true, "‚ùå Should be marked as injured");
  console.assert(player.lives === 2, "‚ùå Should reduce one life");
  console.log("‚úÖ testPlayerInjury passed.");
}

function testPlayerCollectHeart() {
  const player = new Player();
  player.lives = 2;

  // ‚úÖ Mock
  currentMap = createMockMap();
  const heart = { type: "heart", pos: { x: 0, y: 0 } };
  currentMap.itemList.push(heart);

  CollisionController = {
    isTouching: () => heart  // Simulate touching a heart item
  };

  player.checkItemCollision();

  console.assert(player.lives === 3, "‚ùå Should increase one life");
  console.assert(currentMap.itemList.length === 0, "‚ùå Item should be removed");
  console.log("‚úÖ testPlayerCollectHeart passed.");
}

function testPlayerCollectKey() {
  const player = new Player();
  player.keys = 0;

  // ‚úÖ Mock
  currentMap = createMockMap();
  const key = { type: "key", pos: { x: 0, y: 0 } };
  currentMap.itemList.push(key);

  CollisionController = {
    isTouching: () => key  // Simulate touching a key item
  };

  player.checkItemCollision();

  console.assert(player.keys === 1, "‚ùå Should increase the number of keys");
  console.assert(currentMap.itemList.length === 0, "‚ùå Key should be removed");
  console.log("‚úÖ testPlayerCollectKey passed.");
}

function testPlayerUseKeyOnDoor() {
  const player = new Player();
  player.keys = 1;

  // ‚úÖ Mock
  currentMap = createMockMap();
  const door = { type: "door", pos: { x: 0, y: 0 } };
  currentMap.itemList.push(door);

  CollisionController = {
    isTouching: () => door  // Simulate touching a door item
  };

  LevelController = {
    nextLevelCalled: false,
    nextLevel() {
      this.nextLevelCalled = true;
    }
  };

  player.checkItemCollision();

  console.assert(player.keys === 0, "‚ùå Should consume a key");
  console.assert(LevelController.nextLevelCalled === true, "‚ùå Should switch to the next level");
  console.log("‚úÖ testPlayerUseKeyOnDoor passed.");
}

function testPlayerIsAlive() {
  const player = new Player();
  player.lives = 1;
  console.assert(player.isAlive() === true, "‚ùå Player should be alive");

  player.lives = 0;
  console.assert(player.isAlive() === false, "‚ùå Player should be dead");
  console.log("‚úÖ testPlayerIsAlive passed.");
}

function testPlayerMoveLeft() {
    const player = new Player();
    player.pos.x = 100;
  
    // ‚úÖ Mock
    currentMap = createMockMap();
  
    // Simulate that there is no wall or obstruction
    player.moveLeft();
  
    console.assert(player.pos.x === 95, "‚ùå Player should move left by 5 units");
    console.log("‚úÖ testPlayerMoveLeft passed.");
  }
  
  function testPlayerMoveRight() {
    const player = new Player();
    player.pos.x = 100;
  
    // ‚úÖ Mock
    currentMap = createMockMap();
  
    // Simulate that there is no wall or obstruction
    player.moveRight();
  
    console.assert(player.pos.x === 105, "‚ùå Player should move right by 5 units");
    console.log("‚úÖ testPlayerMoveRight passed.");
  }
  
  function testPlayerJump() {
    const player = new Player();
    player.pos.y = 100;
  
    // ‚úÖ Mock
    player.onWall = () => "bottom"; // Simulate standing on the ground
    player.jump();
  
    console.assert(player.velocity.y === -17, "‚ùå Jump velocity should be -17");
    console.assert(player.pos.y === 100, "‚ùå Player's position should not change until gravity acts");
    console.log("‚úÖ testPlayerJump passed.");
  }

  function testPlayerShoot() {
    console.log("‚úÖ Running testPlayerShoot...");
  
    const testPlayer = new Player();
    testPlayer.pos = createVector(100, 100); 
    currentMap = {
      xOffset: 0,
      yOffset: 0,
      blocks: Array(10).fill().map(() => Array(10).fill(0)) // blank map
    };
  
    mouseX = 200;
    mouseY = 150;
  
    let originalPistol = pistol;
    if (originalPistol !== 0 && originalPistol !== 1) {
      pistol = 0;
      originalPistol = 0;
    }
  
    testPlayer.togglePistol();
    console.assert(pistol === 1 - originalPistol, `üîÅ togglePistol failed. Expected ${1 - originalPistol}, got ${pistol}`);
  
    testPlayer.togglePistol();
    console.assert(pistol === originalPistol, `üîÅ togglePistol failed to toggle back. Expected ${originalPistol}, got ${pistol}`);
  
    const shootType = "blue";
    testPlayer.shoot(shootType);
  
    console.assert(testPlayer.bullet instanceof Bullet, "‚ùå Bullet was not created properly.");
    console.assert(testPlayer.bullet.type === shootType, `‚ùå Bullet type mismatch. Expected ${shootType}, got ${testPlayer.bullet.type}`);
  
    const vel = testPlayer.bullet.velocity.copy().setMag(1);
    console.assert(!isNaN(vel.x) && !isNaN(vel.y), `‚ùå Bullet velocity is invalid: ${testPlayer.bullet.velocity}`);
  
    console.log("‚úÖ testPlayerShoot passed.");
  }
  
  function testBulletReflection() {
    console.log("‚úÖ Running testBulletReflection...");
    setupMockVectorSystemIfNeeded();
  
    // ‚úÖ Mock ‰∏ÄÂàáÁõ∏ÂÖ≥ÊñπÊ≥ï
    Bullet.prototype.getEntryDirection = function () {
      console.log("üß™ Mocked entry direction: right");
      return "right";
    };
  
    const map = createMockMap();
    const wall = new DirectionWall(250, 250, [5, 0], "reflectRight");
    wall.direction = ["right"];
    map.blocks[5][5] = wall;
    currentMap = map;
  
    globalThis.mouseX = 275;
    globalThis.mouseY = 275;
    const bullet = new Bullet(350, 250, mouseX, mouseY, [0, 5], "blue");
  
    const result = bullet.update();
  
    console.log("‚û°Ô∏è Entry direction =", bullet.getEntryDirection());
    console.log("üìå Block type =", wall.type);
    console.log("üìå Allowed directions =", wall.direction);
    console.assert(bullet.velocity.x < 0, "‚ùå bullet x ÊñπÂêëÂ∫îÂèçËΩ¨‰∏∫Ë¥üÊï∞");
    console.log("‚úÖ testBulletReflection passed.");
  }
  

  function testPlayerTeleportation() {
    console.log("‚úÖ Running testPlayerTeleportation...");
  
    const map = createMockMap();
  
    // ÂÅáËÆæ‰ªéÂè≥‰æß portal ‰º†ÈÄÅÂà∞Â∑¶‰æß portal
    map.blocks[5][6] = new Portal(6 * 50, 5 * 50, [3, 1], "blue", "left");
    map.blocks[5][3] = new Portal(3 * 50, 5 * 50, [2, 1], "red", "right");
  
    currentMap = map;
  
    const player = new Player();
    player.pos.x = 6 * 50 - 10;  // Èù†ËøëÂÖ•Âè£ portal ÁöÑÂ∑¶Ëæπ
    player.pos.y = 5 * 50;
  
    const before = player.pos.copy();
    player.teleport();
    const after = player.pos;
  
    console.assert(before.x !== after.x || before.y !== after.y, "‚ùå Áé©ÂÆ∂‰ΩçÁΩÆÂ∫îÊîπÂèò");
    console.log("‚úÖ testPlayerTeleportation passed.");
  }
  
  function testPlayerPortalEntryDirectionStrict() {
    console.log("‚úÖ Running testPlayerPortalEntryDirectionStrict...");
  
    const player = new Player();
  
    // ‚úÖ top Èó®Ôºö‰ªé‰∏äËøõÂÖ• ‚úÖÔºå‰ªé‰∏ãËøõÂÖ• ‚ùå
    const map1 = createMockMap();
    map1.blocks[10][10] = new Portal(10 * 50, 10 * 50, [0, 1], "blue", "top");
    map1.blocks[8][8] = new Portal(8 * 50, 8 * 50, [1, 1], "red", "bottom");
    currentMap = map1;
  
    player.pos.x = 10 * 50;
    player.pos.y = 10 * 50 - 49; // ‚úÖ ‰ªé‰∏äÊñπËøõÂÖ• top
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x !== after.x || before.y !== after.y, "‚ùå ‰ªé‰∏äËøõÂÖ• top Èó®Â∫î‰º†ÈÄÅ");

  
    player.pos.x = 10 * 50;
    player.pos.y = 11 * 50; // ‚ùå ‰ªé‰∏ãËøõÂÖ• top
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x === after.x && before.y === after.y, "‚ùå ‰ªé‰∏ãËøõÂÖ• top Èó®‰∏çÂ∫î‰º†ÈÄÅ");
  
    // ‚úÖ bottom Èó®Ôºö‰ªé‰∏ãËøõÂÖ• ‚úÖÔºå‰ªé‰∏äËøõÂÖ• ‚ùå
    const map2 = createMockMap();
    map2.blocks[8][8] = new Portal(8 * 50, 8 * 50, [0, 1], "blue", "bottom");
    map2.blocks[6][6] = new Portal(6 * 50, 6 * 50, [1, 1], "red", "top");
    currentMap = map2;
  
    player.pos.x = 8 * 50;
    player.pos.y = 9 * 50; // ‚úÖ ‰ªé‰∏ãËøõÂÖ• bottom
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x !== after.x || before.y !== after.y, "‚ùå ‰ªé‰∏ãËøõÂÖ• bottom Èó®Â∫î‰º†ÈÄÅ");
  
    player.pos.x = 8 * 50;
    player.pos.y = 7 * 50; // ‚ùå ‰ªé‰∏äËøõÂÖ• bottom
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x === after.x && before.y === after.y, "‚ùå ‰ªé‰∏äËøõÂÖ• bottom Èó®‰∏çÂ∫î‰º†ÈÄÅ");
  
    // ‚úÖ left Èó®Ôºö‰ªéÂ∑¶ËøõÂÖ• ‚úÖÔºå‰ªéÂè≥ËøõÂÖ• ‚ùå
    const map3 = createMockMap();
    map3.blocks[5][12] = new Portal(12 * 50, 5 * 50, [0, 1], "blue", "left");
    map3.blocks[4][4] = new Portal(4 * 50, 4 * 50, [1, 1], "red", "right");
    currentMap = map3;
  
    player.pos.x = 11 * 50;
    player.pos.y = 5 * 50; // ‚úÖ ‰ªéÂ∑¶ËøõÂÖ• left
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x !== after.x || before.y !== after.y, "‚ùå ‰ªéÂ∑¶ËøõÂÖ• left Èó®Â∫î‰º†ÈÄÅ");
  
    player.pos.x = 13 * 50;
    player.pos.y = 5 * 50; // ‚ùå ‰ªéÂè≥ËøõÂÖ• left
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x === after.x && before.y === after.y, "‚ùå ‰ªéÂè≥ËøõÂÖ• left Èó®‰∏çÂ∫î‰º†ÈÄÅ");
  
    // ‚úÖ right Èó®Ôºö‰ªéÂè≥ËøõÂÖ• ‚úÖÔºå‰ªéÂ∑¶ËøõÂÖ• ‚ùå
    const map4 = createMockMap();
    map4.blocks[12][6] = new Portal(6 * 50, 12 * 50, [0, 1], "blue", "right");
    map4.blocks[14][8] = new Portal(8 * 50, 14 * 50, [1, 1], "red", "left");
    currentMap = map4;
  
    player.pos.x = 7 * 50;
    player.pos.y = 12 * 50; // ‚úÖ ‰ªéÂè≥ËøõÂÖ• right
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x !== after.x || before.y !== after.y, "‚ùå ‰ªéÂè≥ËøõÂÖ• right Èó®Â∫î‰º†ÈÄÅ");
  
    player.pos.x = 5 * 50;
    player.pos.y = 12 * 50; // ‚ùå ‰ªéÂ∑¶ËøõÂÖ• right
    before = player.pos.copy();
    player.teleport();
    after = player.pos.copy();
    console.assert(before.x === after.x && before.y === after.y, "‚ùå ‰ªéÂ∑¶ËøõÂÖ• right Èó®‰∏çÂ∫î‰º†ÈÄÅ");
  
    console.log("‚úÖ testPlayerPortalEntryDirectionStrict passed.");
  }
  
  
  
  
  